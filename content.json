{"meta":{"title":"Elvis's tech notes | 筆記小本本","subtitle":null,"description":null,"author":"ElvisLiao","url":"https://elvisliao.github.io"},"pages":[{"title":"Javascript","date":"2018-01-18T08:33:49.000Z","updated":"2018-01-18T08:33:49.602Z","comments":true,"path":"Javascript/index.html","permalink":"https://elvisliao.github.io/Javascript/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-18T08:44:25.000Z","updated":"2018-01-18T08:44:25.203Z","comments":true,"path":"categories/index.html","permalink":"https://elvisliao.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"如何淺顯易懂 JavaScript closure 閉包","slug":"如何淺顯易懂-JavaScript-closure-閉包","date":"2018-01-23T03:00:03.000Z","updated":"2018-01-24T10:37:46.670Z","comments":true,"path":"2018/01/23/如何淺顯易懂-JavaScript-closure-閉包/","link":"","permalink":"https://elvisliao.github.io/2018/01/23/如何淺顯易懂-JavaScript-closure-閉包/","excerpt":"","text":"相信或多或少都會看到這個名詞，我也是在某次面試過程中被考到closure，然後就似懂非懂只知道很多function包在一起，沒有在使用、沒熟讀過，可想而知腦帶就一片空白。現在就一口氣把它給弄個清楚，相關的資料結構還有Callback、Promise等，等我整理完文章再全部發上來。 closure(閉包)定義首先，先看一下在MDN上面的解釋： 閉包（Closure）是函式的組合，以及該宣告函式所包含的作用域環境（lexical environment）。 例子： 12345678function init() &#123; var name = &quot;Mozilla&quot;; // name 是個由 init 建立的局部變數 function displayName() &#123; // displayName() 是內部函式，一個閉包 alert(name); // 使用了父函式宣告的變數 &#125; displayName();&#125;init(); init() 建立了局部變數 name 與 displayName() 函式。displayName() 是個在 init() 內定義的內部函式，且只在該函式內做動。displayName() 自己並沒有局部變數，不過它可以訪問外面函式的變數、因而能取用在父函式宣告的變數 name。 好，我還是白話一點好了。 JavaScript函式可以像一般的數值那樣的使用，可以在變數、物件或陣列中儲存，也可以傳入到另外的函式裡當參數、當回傳值回傳。 而依照函式作用域的連鎖規則，內部函式可以看到、讀取到外部函式，而形成一個Scope Chain(作用域連鎖)，所以內部函式可以有三個作用域： 自已本身 外部函式的 全域 閉包可以說它是一種技術，或是一種資料結構，或是有記憶環境值的函式。在JavaScript中每當函式被建立時，一個閉包就會被產生，閉包是一個函式建立時就有的自然特性。 什麼叫記憶環境值？以下用兩個例子來示範： 不使用closure123456789101112131415161718192021222324var count = 0function countRed () &#123; count += 1 console.log(count + &apos; Red(s)&apos;)&#125;// 中間是其他程式碼...var count = 0function countGreen () &#123; count += 1 console.log(count + &apos; Green(s)&apos;)&#125;countRed() // 1 Red(s)countRed() // 2 Red(s)countRed() // 3 Red(s)countGreen() // 4 Green(s)，我希望是 1 Green(s)countGreen() // 5 Green(s)，我希望是 2 Green(s)countRed() // 6 Red(s)，我希望是 4 Red(s) 由於把值都記在了全域變數的count底下，所以當在執行的時候數量全都不對了。或許你會說，這個錯誤不太可能發生、變數取不一樣的名稱就好。但是在一個大型專案中，程式上萬行或是還有其他的協作者，大家都叫count的情況下，是不是就會錯誤了呢？ 使用closure來生成private 變數由上個例子我們會知道，如果使用全域變數是可能會發生大問題的，這個時候我們可以利用closure的記憶環境值特性來避免，讓函式有自己的private變數來做count。 12345678910111213141516171819function createCounter (color) &#123; var count = 0 return function () &#123; count++ console.log(count + &apos; &apos; + color) &#125;&#125;const RedCounter = createCounter(&apos;red&apos;)const GreenCounter = createCounter(&apos;green&apos;)const BlackCounter = createCounter(&apos;black&apos;)RedCounter() // 1 redRedCounter() // 2 redGreenCounter() // 1 greenGreenCounter() // 2 greenBlackCounter() // 1 blackdogCounter() // 3 redGreenCounter() // 3 cat 以上例子因為Closure記憶環境值的特性讓每個呼叫函式都有自己一個count了，所以就算以後有再多的項目，也不用增加多餘的程式碼去判斷，上述的程式碼中有幾個重點概念： 匿名函數：return的函式我們已經簡化成了匿名函式，或者你也可以使用Arrow function來讓程式碼更加的簡潔。 1234return () =&gt; &#123; count++ console.log(count + &apos; &apos; + color) &#125; 記憶環境值：每重新定義一個createCounter()函式，都可以有自己的private 變數，不會互相干擾。因為closure是參照(refer)這些值，而非複製(copy)。 常用實例常用實例首先就是上述講的避免在使用全域變數的地方上，第二點就是使用在迴圈賦值上。不知道你有沒有那個經驗，有時候在一個迴圈賦值的時候一直給不上去，每次都存到了迴圈的最後一筆資料？原因就是如果迴圈中有了異步回調，那它會先移到工作佇列中準備執行異部處理(setTimeout、AJAX等)，等它回來主執行緒執行時，迴圈早就跳出執行了，而且i還已經跑到了最後一個，所以接下來執行的動作，能獲取到的值全部都是錯的。這時候如果使用closure的話，可以在迴圈每跑一次就執行一次的closure函式，將值記錄在裡面並且輸出，可以確保程式不會亂掉。 至於實際的範例可以參考這邊：JSbin 參考網站閉包- JavaScript | MDN從ES6開始的JavaScript學習生活深入淺出瞭解 JavaScript 閉包（closure）Javascript - 淺談this與Closure","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}],"tags":[{"name":"Closure","slug":"Closure","permalink":"https://elvisliao.github.io/tags/Closure/"},{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}]},{"title":"利用HEXO架設屬於自己的BLOG","slug":"利用HEXO架設專屬自己的BLOG","date":"2018-01-22T08:33:02.000Z","updated":"2018-01-22T09:41:22.643Z","comments":true,"path":"2018/01/22/利用HEXO架設專屬自己的BLOG/","link":"","permalink":"https://elvisliao.github.io/2018/01/22/利用HEXO架設專屬自己的BLOG/","excerpt":"","text":"過去曾用過WordPress、logdown等等來撰寫文章，但都一直無法讓自己滿意，不是架設太複雜就是很難去客製化自己的主題。基本主題東改改西改改，花費的時間一多，就喪失了隨手寫Blog的意義了。 在一個偶然的情況下，逛到一個技術部落格，就是使用HEXO來實現，簡潔、快速架設、美觀的優點正好是我需要的，於是這個站就這麼產生了。 安裝 Hexo：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 如果有任何的問題，Hexo官網也都有很詳細的操作文件可以參考，只要照著步驟都可以完成。 另外，主題方面，要找到自己喜歡的真不容易。好險Hexo提供了很多Theme讓人套用，如果你覺的自己客製出來的主題很厲害，也都可以pull request。 主題套用方法，一樣可以參考操作手冊，一切都是非常的懶人非常簡單。 發布至GithubHexo deploy可以部署到很多個平台，具體可以參考這個連結。如果部署到github，需要在配置文件_config.xml中作如下修改： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 常用指令： hexo generate (hexo g) 生成靜態文件，會在當前目錄下生成一個新的叫做public的文件夾。 hexo server (hexo s) 啟動Local web服務，用於Hexo的預覽 hexo deploy (hexo d) 部署到遠端（比如github, heroku等平台） 這邊有一個我常用的組合指令： hexo clean &amp;&amp; hexo d -g 它就是將上面一整串合併在一起，然後產生靜態檔，最後發布到github上。","categories":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://elvisliao.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://elvisliao.github.io/tags/blog/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}]}]}