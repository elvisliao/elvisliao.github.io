{"meta":{"title":"Elvis's tech notes","subtitle":null,"description":null,"author":"ElvisLiao","url":"https://elvisliao.github.io"},"pages":[{"title":"Javascript","date":"2018-01-18T08:33:49.000Z","updated":"2018-01-18T08:33:49.603Z","comments":true,"path":"Javascript/index.html","permalink":"https://elvisliao.github.io/Javascript/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-18T08:44:25.000Z","updated":"2018-01-18T08:44:25.203Z","comments":true,"path":"categories/index.html","permalink":"https://elvisliao.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Javascript Callback 回調","slug":"Javascript-Callback-回調","date":"2018-01-30T08:04:07.000Z","updated":"2018-03-07T03:23:58.977Z","comments":true,"path":"2018/01/30/Javascript-Callback-回調/","link":"","permalink":"https://elvisliao.github.io/2018/01/30/Javascript-Callback-回調/","excerpt":"","text":"Callback(回調)是什麼？Callback 在英文是”call back”兩個單字的合體，你應該有聽過”Call me back”的英文，實際情況大概是有客戶打來電話給你，可是你正在電話中，客戶會留話說請你等會有空時再”回電”給它。而在程式開發上，callback 的使用其實也是與這類似。 CPS風格與直接風格Callback有兩種風格，分別是：延續傳遞風格(Continuation-passing style, CPS)、直接風格 (Direct style)，這兩種是程式開發時所使用的風格，CPS早在1970年代就已經被提出來了。 CPS風格：CPS用的是明確地移轉控制權到下一個函式中，也就是使用「延續函式」的方式，一般稱它為「回調函式」或「回調(Callback)」。回調是一個可以作為傳入參數的函式，用於在目前的函式呼叫執行最後移交控制權，而不使用函式回傳值的方式。 直接風格：控制權移交是不明確的，它是利用回傳值的方式，進行到下一行程式碼或是呼叫接下來函式。下面以範例來說明會比較容易理解。 假設現在要從資料庫獲取某個會員的資料，然後把裡面的大頭照片輸出。 用直接風格的寫法: 1234567891011function getAvatar(user)&#123; //...一些程式碼 return avatar&#125;function display(avatar)&#123; console.log(avatar)&#125;const avatar = getAvatar('eddy')display(avatar) 用CPS風格的寫法，像下面這樣: 12345678910function getAvatar(user, cb)&#123; //...一些程式碼 cb(avatar)&#125;function display(avatar)&#123; console.log(avatar)&#125;getAvatar('eddy', display) 為什麼要用CPS風格?CPS風格編寫起來這麼不直觀，為什麼要用這樣的寫法？ 過去語言多用在個人電腦或伺服器端，大多是多執行緒或改進底層運作的執行方式，直接風格並不會影響太大的效能問題，所以CPS風格在過去不算很主流。 在JavaScript中會大量使用CPS風格，除了它本身可以使用這種風格外，其實是有原因： 只有單執行緒，事件或網路要求(AJAX)不能阻塞其他程式的進行，使用在伺服器端執行時更是嚴峻，要能夠讓多人同時連線使用，必需達到不阻塞I/O，才能與多執行緒伺服器一樣的有效率。 一開始就是以CPS風格來設計事件異步處理的模型，用於配合異步回調函式的執行使用。 基本上一個程式語言要具有高階函式(High Order Function)的特性才能使用CPS風格，也就是說可以把某個函式當作另一函式的傳入參數，也要可以回傳函式。除了JavaScript語言外，具有高階函式特性的程式語言常見的有Python、Java、Ruby、Swift等等。 CPS風格的缺點 在愈複雜的應用情況時，程式碼愈不易撰寫與組織，維護性與閱讀性也很低(Callback Hell) 在錯誤處理上較為困難 異步回調函式並非所有使用callback函式的API都是異步執行的，除了DOM事件的回調函式9成9都是異步執行的之外，語言內建API中使用的回調函式不一定是異步執行。同步執行的例如 Array.forEach，那要如何讓開發者自訂的callback轉變為異步？有以下幾種方式: 使用計時器(timer)函式： setTimeout、setInterval 特殊的函式： nextTick、setImmediate 執行I/O： 監聽網路、資料庫查詢或讀寫外部資源 訂閱事件 針對callbacks(回調)函式來說，異步與同步的執行到底是差在哪？下面用簡單的例子來說明： 1234567891011121314151617function aFunc(value, callback)&#123; callback(value)&#125;function bFunc(value, callback)&#123; setTimeout(callback, 0, value)&#125;function cb1(value)&#123; console.log(value) &#125;function cb2(value)&#123; console.log(value) &#125;function cb3(value)&#123; console.log(value) &#125;function cb4(value)&#123; console.log(value) &#125;aFunc(1, cb1)bFunc(2, cb2)aFunc(3, cb3)bFunc(4, cb4) aFunc是一個簡單的回調結構，callback回調函式被傳入後最後以value作為傳入參數執行。 bFunc函式則是包裹了一個setTimeout內建方法，它可以在一定時間內(第二個參數)執行第一個參數，也就是setTimeout會執行回調函式，第三個參數是要加入到回調函式的傳入參數值。 aFunc中使用了一般的回調函式，只是傳入到函式中當作參數，然後最後執行而已，這種是同步執行的回調函式，只是用了CPS風格的寫法。 bFunc中使用了計時器APIsetTimeout會把傳入的回調函式進行異步執行，也就是先移到工作佇列中，等執行主執行緒的呼叫堆疊空了，在某個時間回到主執行緒再執行。所以即使它的時間設定為0秒，裡面的回調函式並不是立即執行，而是會暫緩(延時)執行的一種回調函式，一般稱為異步回調函式。 最後的執行結果是1 -&gt; 3 -&gt; 2 -&gt; 4，也就是說，所有的同步回調函式都執行完成了，才會開始依順序執行異步的回調函式。如果你在瀏覽器上測試這個程式，應該會明顯感受到，2與4的輸出時，會有點延遲的現象，這並不是你的瀏覽器或電腦的問題，這是因為不論你設定的setTimeout為0，它要回到主執行緒上執行，仍然需要按照內部事件迴圈所設定的時間差，在某個時間點才會回來執行。 這個程式執行的流程，可以看這個流程模擬，輸出一樣在瀏覽器的主控台中可以看到。 由這個範例中，可以看到異步回調函式執行比同步回調函式更慢，異步回調函式還有另一個名稱是延時回調(defer callback)，是用延時執行特性來命名。這只是一種因應特別情況所採用的函式執行方式，例如需要與外部資源存取(I/O)、DOM事件處理或是計時器的情況。等待的時間則是在Web API中，等有外部資源有回應了(或超時)才會加到佇列中，佇列裡並不會執行函式中的程式碼，只是個準備排隊進入主執行緒的機制，函式一律在主執行緒中執行。 關於函式的異步執行與事件迴圈一些原理的說明，可以參考[異步執行與事件迴圈]。 回調函式的複雜性callback(回調)運用在瀏覽器端似乎並沒有想像中複雜，一個事件的處理範例大概會像下面這樣: 12345const el = document.getElementById('myButton')el.addEventListener( 'click', function()&#123; console.log('hello!')&#125;, false) 你也可以把callback寫成另一個函式定義，看起來會更清楚: 1234567function callback()&#123; console.log('hello!')&#125;const el = document.getElementById('myButton')el.addEventListener('click', callback, false) AJAX是另一個常使用的情況，內建的XMLHttpRequest物件的行為類似於事件處理，而且都打包好好的。實際上onreadystatechange這個屬性，就是XMLHttpRequest物件在處理事件用的callback(回調)函式。以下為一個簡單的範例: 123456789101112131415161718var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == XMLHttpRequest.DONE ) &#123; if (xhr.status == 200) &#123; document.getElementById('myDiv').innerHTML = xhr.responseText &#125; else if (xhr.status == 400) &#123; console.log('There was an error 400') &#125; else &#123; console.log('something else other than 200 was returned') &#125; &#125;&#125;xhr.open('GET', 'ajax_info.txt', true)xhr.send() “匿名函式”、”函式定義”與”函式呼叫”的混合我會認為回調函式會複雜的原因是主要是來自”匿名函式”、”函式定義”與”函式呼叫”的混合寫法。所以當在看程式碼時，你的腦袋很容易打結。 1234567function func(x, cb)&#123; cb(x)&#125;func(123456, function(value)&#123; console.log(value)&#125;) 這例子很簡單，要分作幾個部份來看: 這是一個完整的”函式呼叫”，也就是說它是一個被執行的語句結構: 123func(123456, function(value)&#123; console.log(value)&#125;) 但其中的這一段是什麼，這個是一個”函式定義”，而且還是個”匿名函式”定義，它是一個callback(回調)函式的定義，它代表了func函式執行完後要作的下一件事，這個定義是在func函式中的程式碼的最後一句被呼叫執行。: 123function(value)&#123; console.log(value)&#125; 所以整個語法是代表”在函式呼叫時，要寫出下一個要執行的函式定義“，這就是常見回調函式的語法樣式。當然，你可以另外用一個函式來寫得更清楚: 123456789function func(x, cb)&#123; cb(x)&#125;function callback(value)&#123; console.log(value)&#125;func(123456, callback) 不過，你可以發現幾件事情: callback(回調)的函式名稱，可以用匿名函式取代。(實際上callback的名稱在除錯時很有用，可以在錯誤的堆疊上指示出來) callback(回調)因為是函式的定義，所以傳入參數value的名稱叫什麼其實都可以。 callback(回調)其實有Closure(閉包)結構的特性，可以獲取到func中的傳入參數，以及裡面的定義的值。(實際上JavaScript中只要函式建立就會有閉包產生) 那麼要說到callback(回調)的最大優點，就是它給了程式開發者很大的彈性，允許開發者可以自訂下一個要執行函式的內容，等於說它可以提高函式的擴充性與重覆使用性。 回調地獄(Callback Hell)複雜的情況是在於CPS風格使用callback(回調)來移往下一個函式執行，當你開始撰寫一個接著一個執行的流程，也就是一個特定工作的函式呼叫後要接下一個特定工作的函式時，就會看到所謂的”回調地獄”的結構，像下面這樣的例子: 123456789step1(x, function(value1)&#123; //do something... step2(y, function(value2)&#123; //do something... step3(z, function(value3)&#123; //do something... &#125;) &#125;)&#125;) 它的執行順序應該是step1 -&gt; step2 -&gt; step3沒錯，這三個都可能是已經寫好要作某件特定工作的函式。所以真正是這樣的流程嗎？你可能忘了匿名函式(callback)也是一個函式，所以執行的步驟是像下面這樣才對: step1執行後，”value1”已經有值，移往function(value1)執行 function(value1)執行到step2，step2執行到最後，”value2”已經有值，移往function(value2)執行 function(value2)執行到step3，step3執行到最後，”value3”已經有值，移往function(value3)執行 function(value3)執行完成 寫成流程大概是像下面這樣的順序，一共有6個函式要執行的流程，其中的這三個匿名回調函式的主要工作，是負責準備接續下一個要執行特定工作的函式: 1step1 -&gt; function(value1) -&gt; step2 -&gt; function(value2) -&gt; step3 -&gt; function(value3) 那為何為不使用直接風格？而一定要用這麼不易理解的程式流程結構。上面已經有講為什麼JavaScript中會大量的使用CPS的原因: 因為有些I/O或事件類的函式，用直接風格會造成阻塞，所以要寫成異步的回調函式，也就是一定要用CPS 你可能會認為阻塞有這麼容易發生嗎？是的，在JavaScript中要”阻塞”太容易了，它是單執行緖執行的設計，一個比較長時間的程序執行就會造成阻塞，下面的for迴圈就會讓你的按鈕按下去沒反應，而且幾個訊息都要一段時間執行完才會顯示出來: 12345678910111213141516171819const el = document.getElementById('myButton')el.addEventListener( 'click', function()&#123; alert('hello!')&#125;, false)const aArray = []for(let i=0; i&lt; 100000000;i++)&#123; aArray[i] = i+10&#125;console.log('aArray done!')const bArray = []for(let i=0; i&lt; 100000000;i++)&#123; bArray[i] = i*10&#125;console.log('bArray done!') 或許你會認為在瀏覽器上讓使用者等個幾秒鐘不會怎麼樣，但如果在要求能讓多個使用者同時使用的伺服器上，每個使用者都來阻塞主執行緒幾秒，這個伺服器程式就可以廢了。不過，以異步執行的異步回調函式並不代表就不會阻塞，也有可能從佇列回到主緒行緒後，因為需要CPU密集型的運算，仍然會阻塞到緒行緒的進行。異步回調函式，只是暫時先移到佇列中放著，讓它先不干擾目前的主執行緒的執行而已。這是JavaScript為了在只有單執行緒的情況，用來達成並行(concurrency)模型的設計方式。 如果要配合JavaScript的異步處理流程，也就是非阻塞的I/O處理，只有CPS可以這樣作。 在伺服端的Node.js一開始就使用了CPS作為主要的I/O處理方式，老實說是一個不得已的選擇，當時沒有太多的選擇，而且這原本就是JavaScript中對異步回調函式的設計。Node.js使用error-first(以錯誤為主)的CPS風格，因為考慮到callback(回調)要處理錯誤不容易，所以要優先處理錯誤，它的主要原則如下: callback的第一個參數保留給Error(錯誤)，當錯誤發生時，它將會以第一個參數回傳。 callback的第2個參數保留給成功回應的資料。當沒有錯誤發生時，error(即第一個參數)會設定為null，然後將成功回應的資料傳入第二個參數。 一個典型的Node.js的回調語法範例如下: 123456789var fs = require('fs');fs.readFile('foo.txt', 'utf8', function(err, data) &#123; if(err) &#123; console.log('Unknown Error'); return; &#125; console.log(data);&#125;); Node.js使用CPS風格在複雜的流程時，很容易出現回調地獄的問題，這是因為在伺服器端的各種I/O處理會相當頻繁而且複雜。像下面這個資料庫連接與查詢的範例，出自Node.js MongoDB Driver API: 12345678910111213141516171819202122// A simple query using the find method on the collection.var MongoClient = require('mongodb').MongoClient, test = require('assert');MongoClient.connect('mongodb://localhost:27017/test', function(err, db) &#123; // Create a collection we want to drop later var collection = db.collection('simple_query'); // Insert a bunch of documents for the testing collection.insertMany([&#123;a:1&#125;, &#123;a:2&#125;, &#123;a:3&#125;], &#123;w:1&#125;, function(err, result) &#123; test.equal(null, err); // Peform a simple find and return all the documents collection.find().toArray(function(err, docs) &#123; test.equal(null, err); test.equal(3, docs.length); db.close(); &#125;); &#125;);&#125;); 上面這個範例還算簡單，但裡面的回調函式有3個，函式呼叫了11個，再複雜的話就會更不好維護，我會認為這是一種舊時代的程式碼組織方式的弊病，或是當時不得已的解決方案，當可以採用更好的語法結構來取代它時，這種語法未來大概只會出現在教科書中。現在這種寫法都是一般都已經不建議使用。 現在已經有很多協助處理的方式，回調地獄可以用例如Promise、generator、async/await之類的語法結構，或是Async、co外部函式庫等，來改善或重構原本的程式碼結構，在往後維護程式碼上會比較容易，這些才是你現在應該就要學習的方式。 此外，隨著技術不斷的進步，現在的JavaScript也已經有可以讓它使用其他執行緒的技術，有Web Worker，或是專門給Node.js使用的child_process模組與cluster(叢集)模組。 反樣式(anti-pattern)回傳callbackcallback(回調)有個很常見的反樣式，它會出現在如果回調除了要進行下一步之外，還要負責處理函式在執行中途的錯誤情況，例如: 1234567//這是錯誤的寫法，最後的callback()依然會執行function foo(err, callback) &#123; if (err) &#123; callback(err) &#125; callback()&#125; 為了讓最後的callback()不執行，可以正確的作錯誤處理，有可能會寫成這樣: 1234567//相當不好的寫法function foo(err, callback) &#123; if (err) &#123; return callback(err) &#125; callback()&#125; 但是return用在callback上是個不對的樣式，正確的寫法應該是要用下面的寫法: 1234567function foo(err, callback) &#123; if (err) &#123; callback(err) return &#125; callback()&#125; 或是用if...else寫清楚整個情況，但這個樣式也不是太理想，CPS風格寫法的最後一行應該就是個回調函式: 1234567function foo(err, callback) &#123; if (err) &#123; callback(err); &#125; else &#123; callback(); &#125;&#125; 參考資源 By example: Continuation-passing style in JavaScript Asynchronous programming and continuation-passing style in JavaScript Enforce Return After Callback","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}],"tags":[{"name":"Callback","slug":"Callback","permalink":"https://elvisliao.github.io/tags/Callback/"},{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}]},{"title":"如何淺顯易懂 JavaScript closure 閉包","slug":"如何淺顯易懂-JavaScript-closure-閉包","date":"2017-11-04T03:00:03.000Z","updated":"2018-07-02T16:56:38.327Z","comments":true,"path":"2017/11/04/如何淺顯易懂-JavaScript-closure-閉包/","link":"","permalink":"https://elvisliao.github.io/2017/11/04/如何淺顯易懂-JavaScript-closure-閉包/","excerpt":"","text":"相信或多或少都會看到這個名詞，我也是在某次面試過程中考到closure，然後似懂非懂只知道很多function包在一起，沒有在使用、沒熟讀過，可想而知腦袋就一片空白。現在就一口氣把它給弄個清楚，相關的資料結構還有Callback、Promise等，等我整理完文章再全部發上來。 closure(閉包)定義首先，先看一下在MDN上面的解釋： 閉包（Closure）是函式的組合，以及該宣告函式所包含的作用域環境（lexical environment）。 例子： 12345678function init() &#123; var name = \"Mozilla\"; // name 是個由 init 建立的局部變數 function displayName() &#123; // displayName() 是內部函式，一個閉包 alert(name); // 使用了父函式宣告的變數 &#125; displayName();&#125;init(); init() 建立了局部變數 name 與 displayName() 函式。displayName() 是個在 init() 內定義的內部函式，且只在該函式內做動。displayName() 自己並沒有局部變數，不過它可以訪問外面函式的變數、因而能取用在父函式宣告的變數 name。 好，我還是白話一點好了。 JavaScript函式可以像一般的數值那樣的使用，可以在變數、物件或陣列中儲存，也可以傳入到另外的函式裡當參數、當回傳值回傳。 而依照函式作用域的連鎖規則，內部函式可以看到、讀取到外部函式，而形成一個Scope Chain(作用域連鎖)，所以內部函式可以有三個作用域： 自已本身 外部函式的 全域 閉包可以說它是一種技術，或是一種資料結構，或是有記憶環境值的函式。在JavaScript中每當函式被建立時，一個閉包就會被產生，閉包是一個函式建立時就有的自然特性。 什麼叫記憶環境值？以下用兩個例子來示範： 不使用closure123456789101112131415161718192021222324var count = 0function countRed () &#123; count += 1 console.log(count + ' Red(s)')&#125;// 中間是其他程式碼...var count = 0function countGreen () &#123; count += 1 console.log(count + ' Green(s)')&#125;countRed() // 1 Red(s)countRed() // 2 Red(s)countRed() // 3 Red(s)countGreen() // 4 Green(s)，我希望是 1 Green(s)countGreen() // 5 Green(s)，我希望是 2 Green(s)countRed() // 6 Red(s)，我希望是 4 Red(s) 由於把值都記在了全域變數的count底下，所以當在執行的時候數量全都不對了。或許你會說，這個錯誤不太可能發生、變數取不一樣的名稱就好。但是在一個大型專案中，程式上萬行或是還有其他的協作者，大家都叫count的情況下，是不是就會錯誤了呢？ 使用closure來生成private 變數由上個例子我們會知道，如果使用全域變數是可能會發生大問題的，這個時候我們可以利用closure的記憶環境值特性來避免，讓函式有自己的private變數來做count。 12345678910111213141516171819function createCounter (color) &#123; var count = 0 return function () &#123; count++ console.log(count + ' ' + color) &#125;&#125;const RedCounter = createCounter('red')const GreenCounter = createCounter('green')const BlackCounter = createCounter('black')RedCounter() // 1 redRedCounter() // 2 redGreenCounter() // 1 greenGreenCounter() // 2 greenBlackCounter() // 1 blackRedCounter() // 3 redGreenCounter() // 3 cat 以上例子因為Closure記憶環境值的特性讓每個呼叫函式都有自己一個count了，所以就算以後有再多的項目，也不用增加多餘的程式碼去判斷，上述的程式碼中有幾個重點概念： 匿名函數：return的函式我們已經簡化成了匿名函式，或者你也可以使用Arrow function來讓程式碼更加的簡潔。 1234return () =&gt; &#123; count++ console.log(count + ' ' + color) &#125; 記憶環境值：每重新定義一個createCounter()函式，都可以有自己的private 變數，不會互相干擾。因為closure是參照(refer)這些值，而非複製(copy)。 常用實例常用實例首先就是上述講的避免在使用全域變數的地方上，第二點就是使用在迴圈賦值上。不知道你有沒有那個經驗，有時候在一個迴圈賦值的時候一直給不上去，每次都存到了迴圈的最後一筆資料？原因就是如果迴圈中有了異步回調，那它會先移到工作佇列中準備執行異部處理(setTimeout、AJAX等)，等它回來主執行緒執行時，迴圈早就跳出執行了，而且i還已經跑到了最後一個，所以接下來執行的動作，能獲取到的值全部都是錯的。這時候如果使用closure的話，可以在迴圈每跑一次就執行一次的closure函式，將值記錄在裡面並且輸出，可以確保程式不會亂掉。 至於實際的範例可以參考這邊：JSbin 參考資料閉包- JavaScript | MDN從ES6開始的JavaScript學習生活深入淺出瞭解 JavaScript 閉包（closure）Javascript - 淺談this與Closure fw","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/tags/Javascript/"},{"name":"Closure","slug":"Closure","permalink":"https://elvisliao.github.io/tags/Closure/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"https://elvisliao.github.io/categories/Javascript/"}]},{"title":"VSCode 整合git bash","slug":"VSCode 整合git bash","date":"2017-10-28T12:37:05.000Z","updated":"2018-07-02T17:42:25.573Z","comments":true,"path":"2017/10/28/VSCode 整合git bash/","link":"","permalink":"https://elvisliao.github.io/2017/10/28/VSCode 整合git bash/","excerpt":"","text":"很常用的設定，記錄下來，也幫助一些小兄弟們。 原先的VSCode shell非常的難用，如果熟悉git的話一定會知道git-bash.exe，可以使用linux的shell語法，非常的方便。 請參考以下的設定：打開設定 -&gt; 使用者設定：依據發文時的版本，這個設定在VScode的左下角齒輪裡面，我第一次也是找很久才找到，接著就修改使用者設定setting.json123&#123; \"terminal.integrated.shell.windows\": \"YOUR:\\\\PATH\\\\TO\\\\bin\\\\bash.exe\",&#125; 設定完後重啟VScode記得！一定要設Git目錄下的 bin\\bash.exe，設成git-bash.exe的話，會獨立跳窗開啟，不會整合到VScode。 什麼?不知道Git目錄在哪1$ where git","categories":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://elvisliao.github.io/tags/vscode/"},{"name":"blog","slug":"blog","permalink":"https://elvisliao.github.io/tags/blog/"},{"name":"git","slug":"git","permalink":"https://elvisliao.github.io/tags/git/"},{"name":"shell","slug":"shell","permalink":"https://elvisliao.github.io/tags/shell/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}]},{"title":"利用HEXO架設屬於自己的BLOG","slug":"利用HEXO架設專屬自己的BLOG","date":"2017-10-22T08:33:02.000Z","updated":"2018-07-02T16:13:13.739Z","comments":true,"path":"2017/10/22/利用HEXO架設專屬自己的BLOG/","link":"","permalink":"https://elvisliao.github.io/2017/10/22/利用HEXO架設專屬自己的BLOG/","excerpt":"","text":"過去曾用過WordPress、logdown等等來撰寫文章，但都一直無法讓自己滿意，不是架設太複雜就是很難去客製化自己的主題。基本主題東改改西改改，花費的時間一多，就喪失了隨手寫Blog的意義了。 在一個偶然的情況下，逛到一個技術部落格，就是使用HEXO來實現，簡潔、快速架設、美觀的優點正好是我需要的，於是這個站就這麼產生了。 安裝 Hexo：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 如果有任何的問題，Hexo官網也都有很詳細的操作文件可以參考，只要照著步驟都可以完成。 另外，主題方面，要找到自己喜歡的真不容易。好險Hexo提供了很多Theme讓人套用，如果你覺的自己客製出來的主題很厲害，也都可以pull request。 主題套用方法，一樣可以參考操作手冊，一切都是非常的懶人非常簡單。 發布至GithubHexo deploy可以部署到很多個平台，具體可以參考這個連結。如果部署到github，需要在配置文件_config.xml中作如下修改： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 常用指令： hexo generate (hexo g) 生成靜態文件，會在當前目錄下生成一個新的叫做public的文件夾。 hexo server (hexo s) 啟動Local web服務，用於Hexo的預覽 hexo deploy (hexo d) 部署到遠端（比如github, heroku等平台） 這邊有一個我常用的組合指令： hexo clean &amp;&amp; hexo d -g 它就是將上面一整串合併在一起，然後產生靜態檔，最後發布到github上。","categories":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://elvisliao.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://elvisliao.github.io/tags/hexo/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://elvisliao.github.io/categories/其他/"}]}]}